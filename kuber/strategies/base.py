"""
Base Strategy Module

Defines the abstract base class for all trading strategies and signal types.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional, Dict, Any, List
import pandas as pd


class SignalType(Enum):
    """Types of trading signals."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    STRONG_BUY = "strong_buy"
    STRONG_SELL = "strong_sell"


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.
    
    Attributes:
        symbol: Stock ticker symbol
        signal_type: Type of signal (buy/sell/hold)
        strength: Signal strength from 0.0 to 1.0
        price: Current price when signal was generated
        timestamp: When the signal was generated
        reason: Human-readable explanation
        metadata: Additional signal data
    """
    symbol: str
    signal_type: SignalType
    strength: float = 0.5
    price: float = 0.0
    timestamp: datetime = field(default_factory=datetime.now)
    reason: str = ""
    strategy_name: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        # Clamp strength to [0, 1]
        self.strength = max(0.0, min(1.0, self.strength))
        
    def is_actionable(self) -> bool:
        """Check if signal requires action."""
        return self.signal_type not in (SignalType.HOLD,)
        
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "symbol": self.symbol,
            "signal_type": self.signal_type.value,
            "strength": self.strength,
            "price": self.price,
            "timestamp": self.timestamp.isoformat(),
            "reason": self.reason,
            "strategy_name": self.strategy_name,
            "metadata": self.metadata
        }


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    All strategies must inherit from this class and implement
    the generate_signal method.
    """
    
    def __init__(self, name: str = None, **params):
        """
        Initialize the strategy.
        
        Args:
            name: Strategy name (defaults to class name)
            **params: Strategy-specific parameters
        """
        self.name = name or self.__class__.__name__
        self.params = params
        self._signals_history: List[Signal] = []
        
    @abstractmethod
    def generate_signal(self, symbol: str, data: pd.DataFrame,
                       current_price: float,
                       position: Optional[Any] = None) -> Optional[Signal]:
        """
        Generate a trading signal based on market data.
        
        Args:
            symbol: Stock ticker symbol
            data: Historical OHLCV data as DataFrame
            current_price: Current market price
            position: Current position (if any)
            
        Returns:
            Signal object or None if no signal
        """
        pass
        
    def validate_data(self, data: pd.DataFrame, min_rows: int = 20) -> bool:
        """
        Validate that data is sufficient for analysis.
        
        Args:
            data: DataFrame to validate
            min_rows: Minimum required rows
            
        Returns:
            True if data is valid
        """
        if data is None or data.empty:
            return False
        if len(data) < min_rows:
            return False
        required_cols = {"open", "high", "low", "close"}
        if not required_cols.issubset(data.columns):
            return False
        return True
        
    def get_params(self) -> Dict[str, Any]:
        """Get strategy parameters."""
        return self.params.copy()
        
    def set_params(self, **params) -> None:
        """Update strategy parameters."""
        self.params.update(params)
        
    def get_signals_history(self) -> List[Signal]:
        """Get historical signals generated by this strategy."""
        return self._signals_history.copy()
        
    def clear_history(self) -> None:
        """Clear signals history."""
        self._signals_history = []
        
    def _record_signal(self, signal: Signal) -> None:
        """Record a signal in history."""
        if signal:
            self._signals_history.append(signal)
            
    def calculate_indicators(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate technical indicators needed for the strategy.
        
        Override in subclasses to add specific indicators.
        
        Args:
            data: OHLCV DataFrame
            
        Returns:
            DataFrame with additional indicator columns
        """
        return data.copy()
        
    def __repr__(self) -> str:
        params_str = ", ".join(f"{k}={v}" for k, v in self.params.items())
        return f"{self.name}({params_str})"


class CompositeStrategy(BaseStrategy):
    """
    A strategy that combines multiple sub-strategies.
    
    Aggregates signals from multiple strategies based on voting
    or weighted averaging.
    """
    
    def __init__(self, strategies: List[BaseStrategy],
                 weights: Optional[List[float]] = None,
                 threshold: float = 0.5,
                 name: str = "CompositeStrategy"):
        """
        Initialize composite strategy.
        
        Args:
            strategies: List of strategies to combine
            weights: Weights for each strategy (defaults to equal)
            threshold: Minimum weighted signal strength to act
            name: Strategy name
        """
        super().__init__(name=name, threshold=threshold)
        self.strategies = strategies
        
        if weights is None:
            self.weights = [1.0 / len(strategies)] * len(strategies)
        else:
            total = sum(weights)
            self.weights = [w / total for w in weights]
            
        self.threshold = threshold
        
    def generate_signal(self, symbol: str, data: pd.DataFrame,
                       current_price: float,
                       position: Optional[Any] = None) -> Optional[Signal]:
        """Generate signal by combining sub-strategy signals."""
        
        buy_score = 0.0
        sell_score = 0.0
        reasons = []
        
        for strategy, weight in zip(self.strategies, self.weights):
            signal = strategy.generate_signal(symbol, data, current_price, position)
            
            if signal:
                if signal.signal_type in (SignalType.BUY, SignalType.STRONG_BUY):
                    buy_score += weight * signal.strength
                    reasons.append(f"{strategy.name}: BUY")
                elif signal.signal_type in (SignalType.SELL, SignalType.STRONG_SELL):
                    sell_score += weight * signal.strength
                    reasons.append(f"{strategy.name}: SELL")
                    
        # Determine overall signal
        if buy_score > sell_score and buy_score >= self.threshold:
            return Signal(
                symbol=symbol,
                signal_type=SignalType.STRONG_BUY if buy_score > 0.8 else SignalType.BUY,
                strength=buy_score,
                price=current_price,
                reason=" | ".join(reasons),
                metadata={"buy_score": buy_score, "sell_score": sell_score}
            )
        elif sell_score > buy_score and sell_score >= self.threshold:
            return Signal(
                symbol=symbol,
                signal_type=SignalType.STRONG_SELL if sell_score > 0.8 else SignalType.SELL,
                strength=sell_score,
                price=current_price,
                reason=" | ".join(reasons),
                metadata={"buy_score": buy_score, "sell_score": sell_score}
            )
            
        return Signal(
            symbol=symbol,
            signal_type=SignalType.HOLD,
            strength=0.0,
            price=current_price,
            reason="No consensus"
        )
